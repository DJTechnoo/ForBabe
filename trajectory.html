<!DOCTYPE html>
<html>
<canvas id="canvas" height="512" width="1024"></canvas>
<script>

const canvas = document.getElementById("canvas");
const c      = canvas.getContext("2d");
const W      = canvas.width;
const H		 = canvas.height;

document.addEventListener("keydown", keyHandler);
document.addEventListener("keyup", keyHandler);




function keyHandler(evt){
	var state = (evt.type == "keydown")? true:false;
	switch(evt.key){
		case 'a': controlls.l = state; break;
		case 'd': controlls.r = state; break;
		case 'w': controlls.s = state; break;
		case 'i': controlls.scu = state; break;
		case 'k': controlls.scd = state; break;
		case 's': controlls.pr = state; break;
	}
}



var controlls = {
	l:false,
	r:false,
	s:false,
	scu:false,
	scd:false,
	pr:false
};


function rad(d){
	return (Math.PI/180) * d;
}

function deg(r){
	return r / (Math.PI/180);
}

function square(x, y, w, h, col){
	c.fillStyle = col;
	c.fillRect(x, y, w, h);
}

function clear(){
	square(0, 0, W, H, "rgba(0,0,0,0.7)");
}


O = function(x, y){
	this.x = x;
	this.y = y;
	this.rot = 0;
	this.rotV = 0;
	this.s = 20;
	this.aimBullet = new Bullet(this.x+this.s/2, this.y+this.s/2, this.rot, 5, 0,0);
	
	
	this.checkControlls = function(){
		if(controlls.l) this.rotate(-1);
		if(controlls.r) this.rotate(1);
		if(controlls.s) this.shoot();
		if(controlls.scu) this.powerctrl(1);
		if(controlls.scd) this.powerctrl(-1);
		if(controlls.pr) this.preview();
		
	}
	
	
	this.update = function(){
		this.checkControlls();
		this.rot += this.rotV;
		this.rotV *= 0.97;
	}
	
	this.preview = function(){
		this.aimBullet = new Bullet(this.x+this.s/2, this.y+this.s/2, this.rot, 10, 0,0);
		while(this.aimBullet.y+this.aimBullet.s < H){
			this.aimBullet.update();
		}
		
		var dy = (this.aimBullet.y + this.aimBullet.s) - H;
		if(dy > 0){
			var atan = Math.atan2(this.aimBullet.vy, this.aimBullet.vx);
			atan = deg(atan)-90;
			var m = 1;
			if(atan < 0) m = -1;
			//atan = Math.sqrt(atan*atan);
			var hyp = dy/Math.cos(rad(atan));
			var dx = Math.sqrt(hyp*hyp - (dy*dy));
			this.aimBullet.x += dx*m;
			this.aimBullet.y = H-this.aimBullet.s;
		}
		//this.aimBullet.draw();
	}
	
	this.rotate = function(l){
		this.rotV += 0.01 * l;
	}
	
	this.powerctrl = function(l){
		power += 0.1*l;
	}
	
	this.shoot = function(){
		bullets.push(new Bullet(
						x+Math.random()*this.s, 
						y+Math.random()*this.s, 
						this.rot, 
						Math.random()*2+0.5, // size
						Math.random()*0.1-0.05,
						Math.random()*0.1-0.05));
	}
	
	
	this.draw = function(){
		
		
		c.save();
		c.translate(this.x+this.s/2, this.y+this.s/2);
		c.rotate(rad(this.rot));
		
		square(-this.s/2, -this.s/2, this.s, this.s, "gold");
		c.restore();
		this.aimBullet.drawAim();
	}
	
	this.preview();

}

const G = 0.01;
var power = 3;

Bullet = function(x, y, r, s, offset, offsetSpd){
	this.s = s;
	this.x = x-this.s/2;
	this.y = y-this.s/2;
	this.rot = r;
	this.SPD = power + offsetSpd;
	this.vx = Math.cos(rad(this.rot)) * this.SPD+offset;
	this.vy = Math.sin(rad(this.rot)) * this.SPD;
	this.dead = false;
	
}

Bullet.prototype.draw = function() {
		
		c.save();
		c.translate(this.x+this.s/2, this.y+this.s/2);
		c.rotate(this.rot);
		
		square(-this.s/2, -this.s/2, this.s*4, this.s, "lime");
		c.restore();
}

Bullet.prototype.drawAim = function() {
		
		c.save();
		c.translate(this.x+this.s/2, this.y+this.s/2);
		c.rotate(this.rot);
		
		square(-this.s/2, -this.s/2, this.s*4, this.s, "grey");
		c.restore();
}

Bullet.prototype.update = function(){
		this.x += this.vx;
		this.y += this.vy;
		this.vy += G;
		this.vx -= 0.01;
		this.rot = Math.atan2(this.vy, this.vx);
		this.stuck = false;
		if(this.y >= H) this.dead = true;
}

const ROW = 100;
const COL = 100;
const BLOCKSEPARATION = 100;


Background = function(s, ox, oy){
	this.offsetX = ox;
	this.offsetY = oy;
	this.x = 0;
	this.y = 0;
	this.s = s;
	
	this.lerp = function(b, p, l, l2){
		this.x = -lerp(p, l, b.x/l2)+ this.offsetX;
		this.y = -lerp(p, l, b.y/l2) + this.offsetY;
	}
	
	this.make = function(){
		for(let i = 0; i < ROW; i++){
			for(let j = 0; j < COL; j++){
				square(this.x + i*BLOCKSEPARATION, this.y + j*BLOCKSEPARATION, this.s, this.s, "white");
			}
		}
	}
}

function lerp(x1, x2, s){
	return x1 + s*(x2-x1);
}


var o = new O(10, H-100);
var bullets = [];

Camera = function(){
	this.x=0;
	this.y=0;
	this.targetX=0;
	this.targetY=0;
	this.follow = function(ob){
		this.targetX = W/2-ob.x;
		this.targetY = H/2-ob.y;
		//console.log(this.targetY);
		if (this.targetY < 0) this.targetY = 0;
		this.x = lerp(this.x, this.targetX, 0.1);
		this.y = lerp(this.y, this.targetY, 0.1);
		c.translate(this.x, this.y);
	}

}

Rail = function(x, y, sep, s, N){
	this.x = x;
	this.y = y;
	this.sep = sep;
	this.s = s;
	this.N = N;
	
	this.draw = function(){
		for(let i = 0; i < this.N; i++){
			square(i*this.sep + this.x, this.y, this.s, this.s, "pink");
		}
	}
}

var cam = new Camera();
var background = new Background(2,-1000,-1000);
var background2 = new Background(4,-1000,-1000);
var rail = new Rail(-40000, H-100, 500, 20, 10000);


function loop(){
	
	clear();
	o.update();
	
	for(let i = bullets.length-1; i >= 0; i--){
		bullets[i].update();
		if(bullets[i].dead) bullets.splice(i, 1);
	}
	
	c.save();
	if(bullets.length>0)
		cam.follow(bullets[0]);
	else cam.follow(o.aimBullet);
	background.lerp(cam, 0, 4000, 4100);
	background2.lerp(cam, 20, 4000, 4500);
	background.make();
	background2.make();
	for(let i in bullets)bullets[i].draw();
	//o.preview();
	o.draw();
	rail.draw();
	c.restore();
	
	requestAnimationFrame(loop);
}

requestAnimationFrame(loop);



</script>



</html>